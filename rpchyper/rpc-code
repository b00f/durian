use crate::v1;
use ethereum_types::{Address, H160, H256, U256, U512};
use jsonrpc_core::futures::{future, Future};
use jsonrpc_core::types::Value;
use jsonrpc_core::Error;
use jsonrpc_core::{BoxFuture, Result};
use v1::helpers::errors;
use v1::traits::TransactionRPC;
use v1::types::TransactionRequest;

pub struct TransactionClient<T: TransactionClientCoreApi> {
	core: T,
}

pub trait TransactionClientCoreApi: Send + Sync + 'static {
	fn send_transaction(&self, _: TransactionRequest) -> BoxFuture<H256>;
	fn gas_price(&self) -> BoxFuture<U256>;
}

pub struct TransactionClientCore {}

impl TransactionClientCore {
	pub fn new() -> TransactionClientCore {
		TransactionClientCore {}
	}
}

pub struct TxHash {
	add_hash: H256,
}

impl TransactionRPC for TransactionClientCore {
	fn gas_price(&self) -> BoxFuture<U256> {
		let trx_count = U256::zero();
		let result = Ok(trx_count);
		Box::new(future::done(result))
	}

	fn send_transaction(&self, request: TransactionRequest) -> BoxFuture<H256> {
		let trx_count = H256::zero();
		let result = Ok(trx_count);
		Box::new(future::done(result))
	}
}

impl<T> TransactionClient<T>
where
	T: TransactionClientCoreApi,
{
	pub fn new(core: T) -> Self {
		TransactionClient { core: core }
	}
}

impl<T> TransactionRPC for TransactionClient<T>
where
	T: TransactionClientCoreApi,
{
	fn gas_price(&self) -> BoxFuture<U256> {
		let trx_count = U256::zero();
		let result = Ok(trx_count);
		Box::new(future::done(result))
	}

	fn send_transaction(&self, request: TransactionRequest) -> BoxFuture<H256> {
		let trx_count = H256::zero();
		let result = Ok(trx_count);
		Box::new(future::done(result))
	}
}
